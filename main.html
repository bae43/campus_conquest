<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>three.js webgl - collada</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel = "stylesheet" type = "text/css" href = "main.css" />
	</head>
	<body>
		<div id="info" color= "#87ceeb">
			
			Model Test
		</div>

		<script src="js/Three.js"></script>
		<script src="js/ColladaLoader.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>

		<script>
            if(!Detector.webgl)
                Detector.addGetWebGLMessage();

            var container, stats;

            var camera, scene, renderer, objects;
            var particleLight, pointLight;
            var dae, skin;

            var loader = new THREE.ColladaLoader();
            loader.options.convertUpAxis = true;
            loader.load('rsc/models/campus.dae', function colladaReady(collada) {

                dae = collada.scene;
                skin = collada.skins[0];

                dae.scale.x = dae.scale.y = dae.scale.z = 1;
                dae.updateMatrix();

                init();
                animate();

            });

            function init() {

               var docElm = document.documentElement;
            if (docElm.requestFullscreen) {
                docElm.requestFullscreen();
            }
            else if (docElm.mozRequestFullScreen) {
                docElm.mozRequestFullScreen();
            }
            else if (docElm.webkitRequestFullScreen) {
                docElm.webkitRequestFullScreen();
            }

                container = document.createElement('div');
                document.body.appendChild(container);

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
                camera.position.set(2, 2, 3);
                scene.add(camera);

                // Grid

                var line_material = new THREE.LineBasicMaterial({
                    color : 0xcccccc,
                    opacity : 0.2
                }), geometry = new THREE.Geometry(), floor = -0.04, step = 1, size = 14;

                for(var i = 0; i <= size / step * 2; i++) {

                    geometry.vertices.push(new THREE.Vector3(-size, floor, i * step - size));
                    geometry.vertices.push(new THREE.Vector3(size, floor, i * step - size));

                    geometry.vertices.push(new THREE.Vector3(i * step - size, floor, -size));
                    geometry.vertices.push(new THREE.Vector3(i * step - size, floor, size));

                }

                var line = new THREE.Line(geometry, line_material, THREE.LinePieces);
                scene.add(line);

                // Add the COLLADA

                scene.add(dae);

                particleLight = new THREE.Mesh(new THREE.SphereGeometry(-5, 8, -3), new THREE.MeshBasicMaterial({
                    color : 0xffffff
                }));
                particleLight.scale = .01;
                scene.add(particleLight);

                // Lights

                scene.add(new THREE.AmbientLight(0xcccccc));

                var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xeeeeee);
                directionalLight.position.x = -2;
                directionalLight.position.y = 2;
                directionalLight.position.z = 1;
                directionalLight.position.normalize();
                scene.add(directionalLight);

                pointLight = new THREE.PointLight(0xffffff, 4);
                pointLight.position = particleLight.position;
                scene.add(pointLight);

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);

                container.appendChild(renderer.domElement);

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild(stats.domElement);

            }

function mouselook() {
                    if(mouseovercanvas) {

                        var mousepos = mouse.getMousePosition();
                        mousepos.x = mousepos.x - document.getElementById("container").offsetLeft;
                        mousepos.y = mousepos.y - document.getElementById("container").offsetTop;

                        //*****highlights hovered
                        try {
                            var obj = gameScene.pick(mousepos.x, mousepos.y).object;

                        } catch(err) {
                            // try{
                            // hoverobj.setMaterial(hoverobj.oldmaterial);
                            //
                            // }catch(err){}
                        }

                        if(obj && mousepos.x && mousepos.y) {

                            obj = gameScene.pick(mousepos.x, mousepos.y).object;

                            if(obj && obj != hoverobj && obj.getId() != "ground-mesh") {

                                if(obj.getId() != "wallobject" && !(obj.getId() in selectedObs)) {
                                    obj.oldmaterial = obj.getMaterial();
                                    obj.setMaterial(highlight);
                                }
                                if(hoverobj && hoverobj.getId() != "wallobject" && !(hoverobj.getId() in selectedObs)) {//selectedObs.hasOwnProperty(hoverobj.getId())
                                    hoverobj.setMaterial(hoverobj.oldmaterial);
                                }
                                hoverobj = obj;

                            } else if(obj != hoverobj && obj.getId() != "ground-mesh") {
                                debug = obj.getId();
                                hoverobj.setMaterial(hoverobj.oldmaterial);
                            }
                        }

                        // *****moves camera

                        inc = (mousepos.y - (document.getElementById('canvas').offsetHeight / 2)) / 500;
                        //		var trans=camera.getRotMatrix().x([0,0,-1,1]);
                        var trans = GLGE.mulMat4Vec4(camera.getRotMatrix(), [0, 0, -1, 1]);
                        var mag = Math.pow(Math.pow(trans[0], 2) + Math.pow(trans[1], 2), 0.5);
                        trans[0] = trans[0] / mag;
                        trans[1] = trans[1] / mag;
                        //  camera.setRotX(1.56 - trans[1] * inc);
                        //  camera.setRotZ(-trans[0] * inc);

                        var height = document.getElementById('canvas').offsetHeight;
                        var width = document.getElementById('canvas').offsetWidth;

                        //fraction of the canvas that cause map to move
                        var xSense = .2;
                        var ySense = .2;

                        var speed = .015 * (camera.getLocZ()) + .01;
                        var ds = 1;

                        //left
                        if(mousepos.x < width * xSense) {
                            ds = 1 - (1 / xSense) * (mousepos.x / width);

                            if(camerapos.x - speed * ds > -2.75) {
                                camera.setLocX(camerapos.x - speed * ds);
                            }
                        }

                        //right
                        if(mousepos.x > width * (1 - xSense)) {
                            ds = (mousepos.x / width - .8) * (1 / xSense);

                            if(camerapos.x + speed * ds < 6) {
                                camera.setLocX(camerapos.x + speed * ds);
                            }
                        }

                        //up
                        if(mousepos.y < height * ySense) {
                            ds = 1 - (1 / ySense) * mousepos.y / height;

                            if(camerapos.y + speed * ds < 3.5) {
                                camera.setLocY(camerapos.y + speed * ds);
                            }

                        }

                        //down
                        if(mousepos.y > height * (1 - ySense)) {
                            ds = (mousepos.y / height - .8) * (1 / ySense);
                            
                            if(camerapos.y - speed * ds > -3.5) {
                            	//alert("moving down");
                                camera.setLocY(camerapos.y - speed * ds);
                            }
                        }
                    }
                }

            //

            var t = 0;
            function animate() {

//mouselook();
                requestAnimationFrame(animate);

                if(t > 30)
                    t = 0;

                if(skin) {

                    // guess this can be done smarter...

                    // (Indeed, there are way more frames than needed and interpolation is not used at all
                    //  could be something like - one morph per each skinning pose keyframe, or even less,
                    //  animation could be resampled, morphing interpolation handles sparse keyframes quite well.
                    //  Simple animation cycles like this look ok with 10-15 frames instead of 100 ;)

                    for(var i = 0; i < skin.morphTargetInfluences.length; i++) {

                        skin.morphTargetInfluences[i] = 0;

                    }

                    skin.morphTargetInfluences[ Math.floor(t)] = 1;

                    t += 0.5;

                }

                render();
                stats.update();

            }

            function render() {

                var timer = Date.now() * 0.0005;

                // //revolve model
                // camera.position.x = Math.cos( timer ) * 12;
                // camera.position.y = 4;
                // camera.position.z = Math.sin( timer ) * 12;
                // camera.lookAt( scene.position );

                renderer.render(scene, camera);

            }

		</script>
		
				<script type="text/javascript">
		// Get a reference to the element.
		var curPlayer = 1;
		
		var elem = document.getElementById('pane');

		// Always check for properties and methods, to make sure your code doesn't break
		// in other browsers.
		if(elem && elem.getContext) {
		// Get the 2d context.
		// Remember: you can only initialize one context per element.
		var context = elem.getContext('2d');
		if(context) {

		// Draw some rectangles.
		context.fillStyle = '#f00';
		// red
		context.fillRect(0, 0, 5, 50);
		context.fillStyle = '#0f0';
		// green
		context.fillRect(0, 50, 5, 50);
		context.fillStyle = '#00f';
		// blue
		context.fillRect(0, 100, 5, 50);
		context.fillStyle = '#ff0';
		// yellow
		context.fillRect(0, 150, 5, 50);
		}

		}

		</script>
	</body>
</html>
