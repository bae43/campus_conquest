<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	<html lang="en">

			<head>

			<title>Terrain Test</title>

			<meta charset="utf-8">

			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

			<style>
				body {
					background: #000;
					color: #fff;
					padding: 0;
					margin: 0;
					font-weight: bold;
					overflow: hidden;
				}

				a {
					color: #ffffff;
				}
				#info {
					position: absolute;
					top: 0px;
					width: 100%;
					color: #ffffff;
					padding: 5px;
					font-family: Monospace;
					font-size: 13px;
					text-align: center;
					z-index: 1000;
				}

			</style>

		</head>

		<body>
					<div id="info">
			Shading Comparison Test-
				<span><a href="" target="_blank">Bryce Evans</a></span>
			</div>


			<script src="../js/Three.js"></script>

			<script src="../js/Detector.js"></script>

			<script src="../js/Stats.js"></script>

			<script>
				if (!Detector.webgl)
					Detector.addGetWebGLMessage();

				var SCREEN_WIDTH = window.innerWidth;

				var SCREEN_HEIGHT = window.innerHeight;

				var container, stats;

				var camera, scene1, scene2, renderer;

	
				init();
				animate();

				function init() {

					container = document.createElement('page');

					document.body.appendChild(container);

					var info = document.getElementById('info');

					container.appendChild(info);

					//

					scene1 = new THREE.Scene();
					scene2 = new THREE.Scene();

					camera = new THREE.PerspectiveCamera(40, 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000);

					camera.position.y = 1000;

					camera.target = new THREE.Vector3(0, 150, 0);

					//

					var light = new THREE.DirectionalLight(0xffffff, 1.3);

					light.position.set(1, 1, 1);

					scene1.add(light);

					var light = new THREE.DirectionalLight(0xffffff, 0.1);

					light.position.set(-1, 2, 0);

					scene1.add(light);

					//

					var light = new THREE.DirectionalLight(0xffffff, 1.3);

					light.position.set(1, 1, 1);

					scene2.add(light);

					var light = new THREE.DirectionalLight(0xffffff, 0.1);

					light.position.set(0.25, -1, 0);

					scene2.add(light);
					//

					var loader = new THREE.JSONLoader();

					loader.load("../rsc/obj/aaa_ground/ground.js", function(geometry) {

						morphColorsToFaceColors(geometry);

						geometry.computeMorphNormals();

						var material = new THREE.MeshPhongMaterial({
							map : THREE.ImageUtils.loadTexture("../rsc/obj/aaa_ground/ground.png"),
							color : 0xffffff,
							shading : THREE.FlatShading,
							perPixel : false
						});

						var mesh = new THREE.Mesh(geometry, material);

						var scale = 10;
						mesh.scale.set(scale, scale, scale);

						mesh.position.y = 150;

						scene1.add(mesh);

						morphs.push(mesh);

					});

					loader.load("../rsc/obj/aaa_ground/ground.js", function(geometry) {

						morphColorsToFaceColors(geometry);

						geometry.computeMorphNormals();

						var material = new THREE.MeshPhongMaterial({
							map : THREE.ImageUtils.loadTexture("../rsc/obj/aaa_ground/ground.png"),
							color : 0xffffff,
							shading : THREE.SmoothShading,
							perPixel : false
						});

						var mesh = new THREE.Mesh(geometry, material);

						var scale = 10;
						mesh.scale.set(scale, scale, scale);

						mesh.position.y = 150;

						scene2.add(mesh);

						morphs.push(mesh);

					});

					//

					renderer = new THREE.WebGLRenderer({
						antialias : true
					});

					renderer.sortObjects = false;

					renderer.autoClear = false;

					renderer.gammaInput = true;

					renderer.gammaOutput = true;

					renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

					container.appendChild(renderer.domElement);

					//

					stats = new Stats();

					stats.domElement.style.position = 'absolute';

					stats.domElement.style.top = '0px';

					stats.domElement.children[ 0 ].children[0].style.color = "#666";

					stats.domElement.children[0].style.background = "transparent";

					stats.domElement.children[ 0 ].children[1].style.display = "none";

					container.appendChild(stats.domElement);

					//

					window.addEventListener('resize', onWindowResize, false);

				}

				function morphColorsToFaceColors(geometry) {

					if (geometry.morphColors && geometry.morphColors.length) {

						var colorMap = geometry.morphColors[0];

						for (var i = 0; i < colorMap.colors.length; i++) {

							geometry.faces[i].color = colorMap.colors[i];

							THREE.ColorUtils.adjustHSV(geometry.faces[i].color, 0, 0.125, 0);

						}

					}

				}

				//

				function onWindowResize(event) {

					SCREEN_WIDTH = window.innerWidth;

					SCREEN_HEIGHT = window.innerHeight;

					renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

					camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;

					camera.updateProjectionMatrix();

				}

				//

				function animate() {

					requestAnimationFrame(animate);

					render();

					stats.update();

				}

				var radius = 600;

				var theta = 0;

				function render() {

					theta += 0.2;

					camera.position.x = radius * Math.sin(theta * Math.PI / 360);

					camera.position.z = radius * Math.cos(theta * Math.PI / 360);

					camera.lookAt(camera.target);

					renderer.clear();

					renderer.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);

					renderer.render(scene1, camera);

					renderer.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);

					renderer.render(scene2, camera);

				}

			</script>

		</body>

	</html>

